<!DOCTYPE html>
<html>
<head>
<title>HTMLCraft</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: ;
  }

  #game-canvas {
    width: 100vw;
    height: 100vh;
    display: block;
  }

  #menu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    color: white;
  }

  #menu button {
    padding: 10px 20px;
    margin: 10px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  }

  #menu button:hover {
    background-color: #3e8e41;
  }

  #crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    pointer-events: none;
    display: none;
  }

  #crosshair::before,
  #crosshair::after {
    content: '';
    position: absolute;
    background-color: white;
  }

  #crosshair::before {
    width: 100%;
    height: 2px;
    top: 50%;
    transform: translateY(-50%);
  }

  #crosshair::after {
    width: 2px;
    height: 100%;
    left: 50%;
    transform: translateX(-50%);
  }
  #hotbar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
  }

  .hotbar-slot {
      width: 40px;
      height: 40px;
      border: 2px solid white;
      margin: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
  }

  #inventory {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      color: white;
      display: none; /* Hidden by default */
  }

  .inventory-slot {
      width: 40px;
      height: 40px;
      border: 2px solid white;
      margin: 5px;
      display: inline-flex;
      justify-content: center;
      align-items: center;
  }

</style>
</head>
<body>
  <canvas id="game-canvas"></canvas>
  <div id="menu">
    <h1>HTMLCraft</h1>
    <button id="play-button">Play</button>
  </div>
  <div id="crosshair"></div>
  <div id="hotbar">
    <div class="hotbar-slot">1</div>
    <div class="hotbar-slot">2</div>
    <div class="hotbar-slot">3</div>
    <div class="hotbar-slot">4</div>
    <div class="hotbar-slot">5</div>
    <div class="hotbar-slot">6</div>
    <div class="hotbar-slot">7</div>
    <div class="hotbar-slot">8</div>
    <div class="hotbar-slot">9</div>
  </div>
  <div id="inventory">
    <h2>Inventory</h2>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <div class="inventory-slot"></div>
    <button id="close-inventory">Close</button>
  </div>

  <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('webgl');
    const menu = document.getElementById('menu');
    const playButton = document.getElementById('play-button');
    const crosshair = document.getElementById('crosshair');
    const inventory = document.getElementById('inventory');
    const closeInventoryButton = document.getElementById('close-inventory');

    let gameRunning = false;
    let camera = {
      x: 0,
      y: 0,
      z: 5,
      pitch: 0,
      yaw: 0,
    };

    let blocks = [];
    let spriteSheet;
    const spriteWidth = 16;
    const spriteHeight = 16;
    let shaderProgram;
    let controller;
    let inventoryOpen = false;

    function initWebGL() {
      // ... (WebGL initialization code from previous examples) ...
      if (!ctx) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
        return;
      }

      ctx.clearColor(0.5, 0.8, 1.0, 1.0);
      ctx.enable(ctx.DEPTH_TEST);

      const vertexShader = createShader(ctx, ctx.VERTEX_SHADER, `
        attribute vec4 aVertexPosition;
        attribute vec2 aTextureCoord;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        varying highp vec2 vTextureCoord;

        void main(void) {
          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
          vTextureCoord = aTextureCoord;
        }
      `);

      const fragmentShader = createShader(ctx, ctx.FRAGMENT_SHADER, `
        varying highp vec2 vTextureCoord;
        uniform sampler2D uSampler;

        void main(void) {
          gl_FragColor = texture2D(uSampler, vTextureCoord);
        }
      `);

      shaderProgram = ctx.createProgram();
      ctx.attachShader(shaderProgram, vertexShader);
      ctx.attachShader(shaderProgram, fragmentShader);
      ctx.linkProgram(shaderProgram);

      if (!ctx.getProgramParameter(shaderProgram, ctx.LINK_STATUS)) {
        alert('Unable to initialize the shader program: ' + ctx.getProgramInfoLog(shaderProgram));
        return;
      }

      ctx.useProgram(shaderProgram);

      spriteSheet = ctx.createTexture();
      const image = new Image();
      image.onload = function() {
        ctx.bindTexture(ctx.TEXTURE_2D, spriteSheet);
        ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, ctx.RGBA, ctx.UNSIGNED_BYTE, image);
        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);
        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);
        ctx.generateMipmap(ctx.TEXTURE_2D);
        ctx.bindTexture(ctx.TEXTURE_2D, null);
      };
      image.src = 'https://minecraft.wiki/images/201007301722_terrain.png?9684e';
      generateWorld();
    }

    function createShader(ctx, type, source) {
      // ... (createShader function from previous examples) ...
      const shader = ctx.createShader(type);
      ctx.shaderSource(shader, source);
      ctx.compileShader(shader);
      if (!ctx.getShaderParameter(shader, ctx.COMPILE_STATUS)) {
        alert('An error occurred compiling the shaders: ' + ctx.getShaderInfoLog(shader));
        ctx.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function generateWorld() {
      // ... (generateWorld function from previous examples) ...
      const worldSize = 5000;
      for (let x = 0; x < worldSize; x++) {
        for (let z = 0; z < worldSize; z++) {
          const height = Math.floor(Math.random() * 3);
          for (let y = 0; y < height; y++) {
            let blockType = 1;
            if (y === height - 1) {
              blockType = 1;
            } else {
              blockType = 2;
            }
            blocks.push({ x: x, y: y, z: z, type: blockType });
          }
        }
      }
    }

    function render() {
        if (!gameRunning) return;
      
      ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT);

      if (spriteSheet && shaderProgram) {
        ctx.useProgram(shaderProgram);
        ctx.bindTexture(ctx.TEXTURE_2D, spriteSheet);

        blocks.forEach(block => {
          drawBlock(ctx, shaderProgram, block.x, block.y, block.z, block.type);
        });
      }

      requestAnimationFrame(render);
    }

    function drawBlock(ctx, shaderProgram, x, y, z, blockType) {
      // ... (drawBlock function from previous examples) ...
      const positions = [
        -0.5 + x, -0.5 + y, 0.5 + z,
        0.5 + x, -0.5 + y, 0.5 + z,
        0.5 + x, 0.5 + y, 0.5 + z,
        -0.5 + x, 0.5 + y, 0.5 + z,
      ];

      const textureCoordinates = calculateTextureCoords(blockType);

      const positionBuffer = ctx.createBuffer();
      ctx.bindBuffer(ctx.ARRAY_BUFFER, positionBuffer);
      ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array(positions), ctx.STATIC_DRAW);

      const textureCoordBuffer = ctx.createBuffer();
      ctx.bindBuffer(ctx.ARRAY_BUFFER, textureCoordBuffer);
      ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array(textureCoordinates), ctx.STATIC_DRAW);

      const positionAttributeLocation = ctx.getAttribLocation(shaderProgram, 'aVertexPosition');
      ctx.enableVertexAttribArray(positionAttributeLocation);
      ctx.vertexAttribPointer(positionAttributeLocation, 3, ctx.FLOAT, false, 0, 0);

      const textureCoordAttributeLocation = ctx.getAttribLocation(shaderProgram, 'aTextureCoord');
      ctx.enableVertexAttribArray(textureCoordAttributeLocation);
      ctx.vertexAttribPointer(textureCoordAttributeLocation, 2, ctx.FLOAT, false, 0, 0);

      const projectionMatrix = mat4.create();
      mat4.perspective(projectionMatrix, Math.PI / 4, canvas.clientWidth / canvas.clientHeight, 0.1, 100.0);

      const modelViewMatrix = mat4.create();
      mat4.translate(modelViewMatrix, modelViewMatrix, [camera.x, camera.y, -camera.z]);
      mat4.rotate(modelViewMatrix, modelViewMatrix, camera.pitch, [1, 0, 0]);
      mat4.rotate(modelViewMatrix, modelViewMatrix, camera.yaw, [0, 1, 0]);

      ctx.uniformMatrix4fv(ctx.getUniformLocation(shaderProgram, 'uProjectionMatrix'), false, projectionMatrix);
      ctx.uniformMatrix4fv(ctx.getUniformLocation(shaderProgram, 'uModelViewMatrix'), false, modelViewMatrix);
      ctx.uniform1i(ctx.getUniformLocation(shaderProgram, 'uSampler'), 0);

      ctx.drawArrays(ctx.TRIANGLE_FAN, 0, 4);
    }

    function calculateTextureCoords(blockType) {
      // ... (calculateTextureCoords function from previous examples) ...
      let u1, v1, u2, v2;
      if (blockType === 1) {
        u1 = 0; v1 = 0; u2 = 1; v2 = 1;
      } else if (blockType === 2) {
        u1 = 1; v1 = 0; u2 = 2; v2 = 1;
      } else if (blockType === 3) {
        u1 = 2; v1 = 0; u2 = 3; v2 = 1;
      }
      return [u1, v1, u2, v1, u2, v2, u1, v2];
    }

    function startGame() {
      gameRunning = true;
      menu.style.display = 'none';
      crosshair.style.display = 'block';
      initWebGL();
      render();
      setupControls();
      setupController();
    }

    function setupControls() {
      // ... (keyboard and mouse controls from previous examples) ...
      document.addEventListener('mousemove', (event) => {
        if (!gameRunning) return;
        camera.yaw -= event.movementX * 0.002;
        camera.pitch -= event.movementY * 0.002;
        camera.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.pitch));
      });
      document.addEventListener('keydown', (event) => {
        if (!gameRunning) return;
        const speed = 0.1;
        const forward = [
          Math.sin(camera.yaw),
          0,
          Math.cos(camera.yaw),
        ];
        const right = [
          Math.cos(camera.yaw),
          0,
          -Math.sin(camera.yaw),
        ];
        if (event.key === 'w') {
          camera.x += forward[0] * speed;
          camera.z += forward[2] * speed;
        } else if (event.key === 's') {
          camera.x -= forward[0] * speed;
          camera.z -= forward[2] * speed;
        } else if (event.key === 'a') {
          camera.x -= right[0] * speed;
          camera.z -= right[2] * speed;
        } else if (event.key === 'd') {
          camera.x += right[0] * speed;
          camera.z += right[2] * speed;
        } else if (event.key === ' ') {
          camera.y += speed;
        } else if (event.key === 'Shift') {
          camera.y -= speed;
        } else if (event.key === 'e') {
          inventoryOpen = !inventoryOpen;
          inventory.style.display = inventoryOpen ? 'block' : 'none';
        }
      });
    }

    function setupController() {
      // ... (controller setup from previous examples) ...
      window.addEventListener('gamepadconnected', (event) => {
        controller = event.gamepad;
        console.log('Gamepad connected.');
      });

      window.addEventListener('gamepaddisconnected', (event) => {
        controller = null;
        console.log('Gamepad disconnected.');
      });
    }

    function updateController() {
      // ... (controller input from previous examples) ...
      if (controller) {
        const gamepad = navigator.getGamepads()[controller.index];
        if (gamepad) {
          const speed = 0.1;
          const yawSpeed = 0.002;
          const pitchSpeed = 0.002;

          const forward = [Math.sin(camera.yaw), 0, Math.cos(camera.yaw)];
          const right = [Math.cos(camera.yaw), 0, -Math.sin(camera.yaw)];

          camera.x += (forward[0] * gamepad.axes[1] * -speed);
          camera.z += (forward[2] * gamepad.axes[1] * -speed);
          camera.x += (right[0] * gamepad.axes[0] * speed);
          camera.z += (right[2] * gamepad.axes[0] * speed);
          camera.y += gamepad.buttons[4].value * speed;
          camera.y -= gamepad.buttons[5].value * speed;

          camera.yaw -= gamepad.axes[2] * yawSpeed;
          camera.pitch -= gamepad.axes[3] * pitchSpeed;
          camera.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.pitch));
        }
      }
    }

    function renderLoop() {
      updateController();
      render();
      requestAnimationFrame(renderLoop);
    }
    playButton.addEventListener('click', startGame);
    closeInventoryButton.addEventListener('click', () => {
        inventoryOpen = false;
        inventory.style.display = 'none';
    })
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
</body>
</html>
